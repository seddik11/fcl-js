import{invariant as e}from"@onflow/util-invariant";import{spawn as n,SUBSCRIBE as t,UNSUBSCRIBE as r,send as o,subscriber as a}from"@onflow/util-actor";import{Buffer as s,encode as i}from"@onflow/rlp";import{sansPrefix as c,withPrefix as u}from"@onflow/util-address";import{SHA3 as l}from"sha3";import{template as d}from"@onflow/util-template";export{template as cadence,template as cdc}from"@onflow/util-template";function p(){return p=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},p.apply(this,arguments)}const m='{\n  "tag":"UNKNOWN",\n  "assigns":{},\n  "status":"OK",\n  "reason":null,\n  "accounts":{},\n  "params":{},\n  "arguments":{},\n  "message": {\n    "cadence":null,\n    "refBlock":null,\n    "computeLimit":null,\n    "proposer":null,\n    "payer":null,\n    "authorizations":[],\n    "params":[],\n    "arguments":[]\n  },\n  "proposer":null,\n  "authorizations":[],\n  "payer":null,\n  "events": {\n    "eventType":null,\n    "start":null,\n    "end":null,\n    "blockIds":[]\n  },\n  "transaction": {\n    "id":null\n  },\n  "block": {\n    "id":null,\n    "height":null,\n    "isSealed":null\n  },\n  "account": {\n    "addr":null\n  },\n  "collection": {\n    "id":null\n  }\n}',f=new Set(Object.keys(JSON.parse(m))),g=()=>JSON.parse(m),h="abcdefghijklmnopqrstuvwxyz0123456789".split(""),y=()=>h[~~(Math.random()*h.length)],k=()=>Array.from({length:10},y).join(""),I=e=>"number"==typeof e,b=e=>Array.isArray(e),w=e=>null!==e&&"object"==typeof e,T=e=>null==e,E=e=>"function"==typeof e,A=e=>{if(!w(e)||T(e)||I(e))return!1;for(let n of f)if(!e.hasOwnProperty(n))return!1;return!0},N=e=>(e.status="OK",e),v=(e,n)=>(e.status="BAD",e.reason=n,e),S=e=>n=>(n.tag=e,N(n)),O=(n,t={})=>r=>{e("function"==typeof n||"object"==typeof n,"prepAccount must be passed an authorization function or an account object"),e(null!=t.role,"Account must have a role");const o=JSON.parse('{\n  "kind":"ACCOUNT",\n  "tempId":null,\n  "addr":null,\n  "keyId":null,\n  "sequenceNum":null,\n  "signature":null,\n  "signingFunction":null,\n  "resolve":null,\n  "role": {\n    "proposer":false,\n    "authorizer":false,\n    "payer":false,\n    "param":false\n  }\n}'),a=t.role,s=k();return n.authorization&&E(n.authorization)&&(n={resolve:n.authorization}),!n.authorization&&E(n)&&(n={resolve:n}),r.accounts[s]=p({},o,{tempId:s},n,{role:p({},o.role,"object"==typeof n.role?n.role:{},{[a]:!0})}),"authorizer"===a?r.authorizations.push(s):r[a]=s,r},C=e=>n=>{let t=k();return n.message.arguments.push(t),n.arguments[t]=JSON.parse('{\n  "kind":"ARGUMENT",\n  "tempId":null,\n  "value":null,\n  "asArgument":null,\n  "xform":null,\n  "resolve": null,\n  "resolveArgument": null\n}'),n.arguments[t].tempId=t,n.arguments[t].value=e.value,n.arguments[t].asArgument=e.asArgument,n.arguments[t].xform=e.xform,n.arguments[t].resolve=e.resolve,n.arguments[t].resolveArgument=E(e.resolveArgument)?e.resolveArgument.bind(e):e.resolveArgument,N(n)},G=S("UNKNOWN"),_=S("SCRIPT"),B=S("TRANSACTION"),L=S("GET_TRANSACTION_STATUS"),x=S("GET_TRANSACTION"),R=S("GET_ACCOUNT"),K=S("GET_EVENTS"),D=S("GET_LATEST_BLOCK"),F=S("GET_BLOCK_BY_ID"),U=S("GET_BLOCK_BY_HEIGHT"),z=S("PING"),P=S("GET_BLOCK"),j=S("GET_BLOCK_HEADER"),H=S("GET_COLLECTION"),$=e=>n=>n.tag===e,q=$("UNKNOWN"),M=$("SCRIPT"),Y=$("TRANSACTION"),W=$("GET_TRANSACTION_STATUS"),J=$("GET_TRANSACTION"),V=$("GET_ACCOUNT"),Z=$("GET_EVENTS"),Q=$("GET_LATEST_BLOCK"),X=$("GET_BLOCK_BY_ID"),ee=$("GET_BLOCK_BY_HEIGHT"),ne=$("PING"),te=$("GET_BLOCK"),re=$("GET_BLOCK_HEADER"),oe=$("GET_COLLECTION"),ae=e=>"OK"===e.status,se=e=>"BAD"===e.status,ie=e=>e.reason,ce=async(e,n=[])=>{try{if(e=(e=>{for(let n of Object.keys(e))if(!f.has(n))throw new Error(`"${n}" is an invalid root level Interaction property.`);return e})(await e),se(e))throw new Error(`Interaction Error: ${e.reason}`);if(!n.length)return e;const[t,...r]=n,o=await t;if(E(o))return ce(o(e),r);if(T(o)||!o)return ce(e,r);if(A(o))return ce(o,r);throw new Error("Invalid Interaction Composition")}catch(e){throw e}},ue=(...e)=>{const[n,t]=e;return b(n)&&null==t?e=>ue(e,n):ce(n,t)},le=e=>e,de=(e,n,t)=>null==e.assigns[n]?t:e.assigns[n],pe=(e,n)=>t=>(t.assigns[e]=n,N(t)),me=(e,n=le)=>t=>(t.assigns[e]=n(t.assigns[e],t),N(t)),fe=e=>n=>(delete n.assigns[e],N(n));var ge={__proto__:null,UNKNOWN:"UNKNOWN",SCRIPT:"SCRIPT",TRANSACTION:"TRANSACTION",GET_TRANSACTION_STATUS:"GET_TRANSACTION_STATUS",GET_ACCOUNT:"GET_ACCOUNT",GET_EVENTS:"GET_EVENTS",GET_LATEST_BLOCK:"GET_LATEST_BLOCK",PING:"PING",GET_TRANSACTION:"GET_TRANSACTION",GET_BLOCK_BY_ID:"GET_BLOCK_BY_ID",GET_BLOCK_BY_HEIGHT:"GET_BLOCK_BY_HEIGHT",GET_BLOCK:"GET_BLOCK",GET_BLOCK_HEADER:"GET_BLOCK_HEADER",GET_COLLECTION:"GET_COLLECTION",BAD:"BAD",OK:"OK",ACCOUNT:"ACCOUNT",PARAM:"PARAM",ARGUMENT:"ARGUMENT",AUTHORIZER:"authorizer",PAYER:"payer",PROPOSER:"proposer",interaction:g,uuid:k,isNumber:I,isArray:b,isObj:w,isNull:T,isFn:E,isInteraction:A,Ok:N,Bad:v,prepAccount:O,makeArgument:C,makeUnknown:G,makeScript:_,makeTransaction:B,makeGetTransactionStatus:L,makeGetTransaction:x,makeGetAccount:R,makeGetEvents:K,makeGetLatestBlock:D,makeGetBlockById:F,makeGetBlockByHeight:U,makePing:z,makeGetBlock:P,makeGetBlockHeader:j,makeGetCollection:H,isUnknown:q,isScript:M,isTransaction:Y,isGetTransactionStatus:W,isGetTransaction:J,isGetAccount:V,isGetEvents:Z,isGetLatestBlock:Q,isGetBlockById:X,isGetBlockByHeight:ee,isPing:ne,isGetBlock:te,isGetBlockHeader:re,isGetCollection:oe,isOk:ae,isBad:se,why:ie,isAccount:e=>"ACCOUNT"===e.kind,isParam:e=>"PARAM"===e.kind,isArgument:e=>"ARGUMENT"===e.kind,pipe:ue,get:de,put:pe,update:me,destroy:fe};function he(e=[]){return ue(g(),e)}const ye="config",ke="PUT_CONFIG",Ie="GET_CONFIG",be="CONFIG/UPDATED",we=e=>e,Te={[ke]:(e,n,{key:t,value:r})=>{if(null==t)throw new Error("Missing 'key' for config/put.");e.put(t,r),e.broadcast(be,p({},e.all()))},[Ie]:(e,n,{key:t,fallback:r})=>{if(null==t)throw new Error("Missing 'key' for config/get");n.reply(e.get(t,r))},GET_ALL_CONFIG:(e,n)=>{n.reply(p({},e.all()))},UPDATE_CONFIG:(e,n,{key:t,fn:r})=>{if(null==t)throw new Error("Missing 'key' for config/update");e.update(t,r||we),e.broadcast(be,p({},e.all()))},DELETE_CONFIG:(e,n,{key:t})=>{if(null==t)throw new Error("Missing 'key' for config/delete");e.delete(t),e.broadcast(be,p({},e.all()))},CLEAR_CONFIG:(e,n)=>{let t=Object.keys(e.all());for(let n of t)e.delete(n);e.broadcast(be,p({},e.all()))},WHERE_CONFIG:(e,n,{pattern:t})=>{if(null==t)throw new Error("Missing 'pattern' for config/where");n.reply(e.where(t))},[t]:(e,n)=>{e.subscribe(n.from),e.send(n.from,be,p({},e.all()))},[r]:(e,n)=>{e.unsubscribe(n.from)}};function Ee(e,n){return o(ye,ke,{key:e,value:n}),Be()}function Ae(e,n){return o(ye,Ie,{key:e,fallback:n},{expectReply:!0,timeout:10})}async function Ne(e=[],n){if(!e.length)return n;const[t,...r]=e,o=await Ae(t);return null==o?Ne(r,n):o}function ve(){return o(ye,"GET_ALL_CONFIG",null,{expectReply:!0,timeout:10})}function Se(e,n=we){return o(ye,"UPDATE_CONFIG",{key:e,fn:n}),Be()}function Oe(e){return o(ye,"DELETE_CONFIG",{key:e}),Be()}function Ce(e){return o(ye,"WHERE_CONFIG",{pattern:e},{expectReply:!0,timeout:10})}function Ge(e){return a(ye,()=>n(Te,ye),e)}function _e(){return o(ye,"CLEAR_CONFIG")}function Be(e){return null!=e&&"object"==typeof e&&Object.keys(e).map(n=>Ee(n,e[n])),{put:Ee,get:Ae,all:ve,first:Ne,update:Se,delete:Oe,where:Ce,subscribe:Ge,overload:xe}}n(Te,ye),Be.put=Ee,Be.get=Ae,Be.all=ve,Be.first=Ne,Be.update=Se,Be.delete=Oe,Be.where=Ce,Be.subscribe=Ge,Be.overload=xe;const Le=e=>e;function xe(e={},n=Le){return new Promise(async(t,r)=>{const o=await ve();try{Be(e);var a=await n(await ve());await _e(),await Be(o),t(a)}catch(e){await _e(),await Be(o),r(e)}})}const Re=()=>JSON.parse('{\n    "tag":null,\n    "transaction":null,\n    "transactionStatus":null,\n    "transactionId":null,\n    "encodedData":null,\n    "events":null,\n    "account":null,\n    "block":null,\n    "blockHeader":null,\n    "latestBlock":null,\n    "collection":null\n}');function Ke(e=null){return ue([P,n=>(n.block.isSealed=e,N(n))])}function De(e){return ue([R,n=>(n.account.addr=c(e),N(n))])}const Fe=async(e,n,t)=>{try{return Number(e)}catch(e){throw new Error(`Decode Number Error : ${t.join(".")}`)}},Ue=async e=>e,ze=async(e,n,t)=>{const r=await e.fields.reduce(async(e,r)=>((e=await e)[r.name]=await He(r.value,n,[...t,r.name]),e),Promise.resolve({})),o=e.id&&je(n,e.id);return o?await o(r):r},Pe={UInt:Fe,Int:Fe,UInt8:Fe,Int8:Fe,UInt16:Fe,Int16:Fe,UInt32:Fe,Int32:Fe,UInt64:Fe,Int64:Fe,UInt128:Fe,Int128:Fe,UInt256:Fe,Int256:Fe,Word8:Fe,Word16:Fe,Word32:Fe,Word64:Fe,UFix64:Ue,Fix64:Ue,String:Ue,Character:Ue,Bool:Ue,Address:Ue,Void:async()=>null,Optional:async(e,n,t)=>e?await He(e,n,t):null,Reference:async e=>({address:e.address,type:e.type}),Array:async(e,n,t)=>await Promise.all(e.map(e=>new Promise(async r=>r(await He(e,n,[...t,e.type]))))),Dictionary:async(e,n,t)=>await e.reduce(async(e,r)=>((e=await e)[await He(r.key,n,[...t,r.key])]=await He(r.value,n,[...t,r.key]),e),Promise.resolve({})),Event:ze,Resource:ze,Struct:ze,Enum:ze,Type:async e=>e.staticType,Path:async e=>({domain:e.domain,identifier:e.identifier}),Capability:async e=>({path:e.path,address:e.address,borrowType:e.borrowType})},je=(e,n)=>{const t=Object.keys(e).find(e=>/^\/.*\/$/.test(e)?new RegExp(e.substring(1,e.length-1)).test(n):e===n);return n&&t&&e[t]},He=async(e,n,t)=>{let r=je(n,e.type);if(!r)throw new Error(`Undefined Decoder Error: ${e.type}@${t.join(".")}`);return await r(e.value,n,t)},$e=async(e,n={},t=[])=>{let r=p({},Pe,n);return await He(e,r,t)},qe=async(e,n={})=>{let t=p({},Pe,n);return e.encodedData?await $e(e.encodedData,t):e.transactionStatus?p({},e.transactionStatus,{events:await Promise.all(e.transactionStatus.events.map(async function(e){return{type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await $e(e.payload,t)}}))}):e.transaction?e.transaction:e.events?await Promise.all(e.events.map(async function(e){return{blockId:e.blockId,blockHeight:e.blockHeight,blockTimestamp:e.blockTimestamp,type:e.type,transactionId:e.transactionId,transactionIndex:e.transactionIndex,eventIndex:e.eventIndex,data:await $e(e.payload,t)}})):e.account?e.account:e.block?e.block:e.blockHeader?e.blockHeader:e.latestBlock?(console.error("\n          %c@onflow/decode Deprecation Notice\n          ========================\n\n          Operating upon data of the latestBlock field of the response object is deprecated and will no longer be recognized in future releases of @onflow/decode.\n          Find out more here: https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field\n\n          =======================\n        ".replace(/\n\s+/g,"\n").trim(),"font-weight:bold;font-family:monospace;"),e.latestBlock):e.transactionId?e.transactionId:e.collection?e.collection:null};function Me(n){return async n=>Y(n)?(n.message.refBlock||(n.message.refBlock=await async function(n){const t=await Be().get("accessNode.api"),r=await Be.first(["sdk.transport","sdk.send"]);var o;return e(r,"Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"),o=await ue(g(),[Ke()]),o=await r(o,{config:Be,response:Re,Buffer:s,ix:ge},{node:t}),(o=await qe(o)).id}()),N(n)):N(n)}const Ye=e=>"function"==typeof e,We=e=>"string"==typeof e;async function Je(n){if(Y(n)||M(n)){var t=de(n,"ix.cadence");e(Ye(t)||We(t),"Cadence needs to be a function or a string."),Ye(t)&&(t=await t({})),e(We(t),"Cadence needs to be a string at this point."),n.message.cadence=await Be().where(/^0x/).then(e=>Object.entries(e).reduce((e,[n,t])=>{const r=new RegExp("(\\b"+n+"\\b)","g");return e.replace(r,t)},t))}return n}const Ve=e=>"function"==typeof e;function Ze(n){return e(null!=typeof n.xform,`No type specified for argument: ${n.value}`),Ve(n.xform)?n.xform(n.value):Ve(n.xform.asArgument)?n.xform.asArgument(n.value):void e(!1,"Invalid Argument",n)}async function Qe(n,t=3){return e(t>0,`Argument Resolve Recursion Limit Exceeded for Arg: ${n.tempId}`),Ve(n.resolveArgument)?Qe(await n.resolveArgument(),t-1):n}async function Xe(e){if(Y(e)||M(e))for(let[n,t]of Object.entries(e.arguments)){const r=await Qe(t);e.arguments[n].asArgument=Ze(r)}return e}const en=e=>an(pn(mn(e))),nn=e=>an(pn(fn(e))),tn=(e,n)=>s.from(e.padStart(2*n,0),"hex"),rn=(on=s.from("FLOW-V0.0-transaction").toString("hex"),s.from(on.padEnd(64,0),"hex")).toString("hex");var on;const an=e=>rn+e,sn=e=>tn(e,8),cn=e=>tn(e,32),un=e=>s.from(JSON.stringify(e),"utf8"),ln=e=>s.from(e,"utf8"),dn=e=>s.from(e,"hex"),pn=e=>i(e).toString("hex"),mn=e=>(yn(e),[ln(e.cadence),e.arguments.map(un),cn(e.refBlock),e.computeLimit,sn(e.proposalKey.address),e.proposalKey.keyId,e.proposalKey.sequenceNum,sn(e.payer),e.authorizers.map(sn)]),fn=e=>(kn(e),[mn(e),gn(e)]),gn=e=>{const n=hn(e);return e.payloadSigs.map(e=>({signerIndex:n.get(e.address),keyId:e.keyId,sig:e.sig})).sort((e,n)=>e.signerIndex>n.signerIndex?1:e.signerIndex<n.signerIndex?-1:e.keyId>n.keyId?1:e.keyId<n.keyId?-1:void 0).map(e=>[e.signerIndex,e.keyId,dn(e.sig)])},hn=e=>{const n=new Map;let t=0;const r=e=>{n.has(e)||(n.set(e,t),t++)};return r(e.proposalKey.address),r(e.payer),e.authorizers.forEach(r),n},yn=e=>{En.forEach(n=>Cn(e,n)),An.forEach(n=>Cn(e.proposalKey,n,"proposalKey"))},kn=e=>{Nn.forEach(n=>Cn(e,n)),e.payloadSigs.forEach((e,n)=>{vn.forEach(t=>Cn(e,t,"payloadSigs",n))})},In=e=>"number"==typeof e,bn=e=>"string"==typeof e,wn=e=>null!==e&&"object"==typeof e,Tn=e=>wn(e)&&e instanceof Array,En=[{name:"cadence",check:bn},{name:"arguments",check:Tn},{name:"refBlock",check:bn,defaultVal:"0"},{name:"computeLimit",check:In},{name:"proposalKey",check:wn},{name:"payer",check:bn},{name:"authorizers",check:Tn}],An=[{name:"address",check:bn},{name:"keyId",check:In},{name:"sequenceNum",check:In}],Nn=[{name:"payloadSigs",check:Tn}],vn=[{name:"address",check:bn},{name:"keyId",check:In},{name:"sig",check:bn}],Sn=[{name:"envelopeSigs",check:Tn}],On=[{name:"address",check:bn},{name:"keyId",check:In},{name:"sig",check:bn}],Cn=(e,n,t,r)=>{const{name:o,check:a,defaultVal:s}=n;if(null==e[o]&&null!=s&&(e[o]=s),null==e[o])throw _n(o,t,r);if(!a(e[o]))throw Bn(o,t,r)},Gn=(e,n,t)=>n?null==t?`${n}.${e}`:`${n}.${t}.${e}`:e,_n=(e,n,t)=>new Error(`Missing field ${Gn(e,n,t)}`),Bn=(e,n,t)=>new Error(`Invalid field ${Gn(e,n,t)}`);function Ln(e){let n=new Set(e.authorizations);return n.add(e.proposer),n.delete(e.payer),Array.from(n)}function xn(e){let n=new Set([e.payer]);return Array.from(n)}const Rn=e=>({cadence:e.message.cadence,refBlock:e.message.refBlock||null,computeLimit:e.message.computeLimit,arguments:e.message.arguments.map(n=>e.arguments[n].asArgument),proposalKey:{address:u(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:u(e.accounts[e.payer].addr),authorizers:(()=>{const n=e.authorizations.map(n=>u(e.accounts[n].addr)).reduce((e,n)=>e.find(e=>e===n)?e:[...e,n],[]);return n[0]?n:[]})(),payloadSigs:Ln(e).map(n=>({address:u(e.accounts[n].addr),keyId:e.accounts[n].keyId,sig:e.accounts[n].signature})),envelopeSigs:xn(e).map(n=>({address:u(e.accounts[n].addr),keyId:e.accounts[n].keyId,sig:e.accounts[n].signature}))}),Kn=e=>(e=>(e=>{const n=new l(256);return n.update(s.from(e,"hex")),n.digest().toString("hex")})(pn((e=>{(e=>{En.forEach(n=>Cn(e,n)),An.forEach(n=>Cn(e.proposalKey,n,"proposalKey")),Nn.forEach(n=>Cn(e,n)),e.payloadSigs.forEach((e,n)=>{vn.forEach(t=>Cn(e,t,"payloadSigs",n))}),Sn.forEach(n=>Cn(e,n)),e.envelopeSigs.forEach((e,n)=>{On.forEach(t=>Cn(e,t,"envelopeSigs",n))})})(e);const n=hn(e),t=e=>e.map(({address:e,keyId:t,sig:r})=>({signerIndex:n.get(e),keyId:t,sig:r})).sort((e,n)=>e.signerIndex>n.signerIndex?1:e.signerIndex<n.signerIndex?-1:e.keyId>n.keyId?1:e.keyId<n.keyId?-1:void 0).map(e=>[e.signerIndex,e.keyId,dn(e.sig)]);return[[ln(e.cadence),e.arguments.map(un),cn(e.refBlock),e.computeLimit,sn(c(e.proposalKey.address)),e.proposalKey.keyId,e.proposalKey.sequenceNum,sn(c(e.payer)),e.authorizers.map(e=>sn(c(e)))],t(e.payloadSigs),t(e.envelopeSigs)]})(e))))(e);function Dn(e,n){try{return{f_type:"PreSignable",f_vsn:"1.0.1",roles:e.role,cadence:n.message.cadence,args:n.message.arguments.map(e=>n.arguments[e].asArgument),data:{},interaction:n,voucher:Rn(n)}}catch(e){throw console.error("buildPreSignable",e),e}}async function Fn(n,t,r,o=3){e(o,"Account Resolve Recursion Limit Exceeded",{ix:n,accounts:t});let a=[];for(let e of t){var s=r||e;"function"==typeof e.resolve&&(e=await e.resolve(e,Dn(e,n))),Array.isArray(e)?await Fn(n,e,s,o-1):(null!=e.addr&&null!=e.keyId&&(e.tempId=`${e.addr}-${e.keyId}`),n.accounts[e.tempId]=n.accounts[e.tempId]||e,n.accounts[e.tempId].role.proposer=n.accounts[e.tempId].role.proposer||e.role.proposer,n.accounts[e.tempId].role.payer=n.accounts[e.tempId].role.payer||e.role.payer,n.accounts[e.tempId].role.authorizer=n.accounts[e.tempId].role.authorizer||e.role.authorizer,n.accounts[e.tempId].role.proposer&&n.proposer===s.tempId&&(n.proposer=e.tempId),n.accounts[e.tempId].role.payer&&n.payer===s.tempId&&(n.payer=e.tempId),n.accounts[e.tempId].role.authorizer&&(r?a=Array.from(new Set([...a,e.tempId])):n.authorizations=n.authorizations.map(n=>n===s.tempId?e.tempId:n))),s.tempId!=e.tempId&&delete n.accounts[s.tempId]}r&&(n.authorizations=n.authorizations.map(e=>e===r.tempId?a:e).reduce((e,n)=>Array.isArray(n)?[...e,...n]:[...e,n],[]))}async function Un(e){if(Y(e))try{await Fn(e,Object.values(e.accounts)),await Fn(e,Object.values(e.accounts))}catch(e){throw console.error("=== SAD PANDA ===\n\n",e,"\n\n=== SAD PANDA ==="),e}return e}async function zn(e){if(Y(e))try{let n=Ln(e);const t=en(jn(e));await Promise.all(n.map(Pn(e,t)));let r=xn(e);const o=nn(p({},jn(e),{payloadSigs:n.map(n=>({address:e.accounts[n].addr,keyId:e.accounts[n].keyId,sig:e.accounts[n].signature}))}));await Promise.all(r.map(Pn(e,o)))}catch(n){throw console.error("Signatures",n,{ix:e}),n}return e}function Pn(e,n){return async function(t){const r=e.accounts[t];if(null!=r.signature)return;const{signature:o}=await r.signingFunction(function(e,n,t){try{return{f_type:"Signable",f_vsn:"1.0.1",message:n,addr:c(e.addr),keyId:e.keyId,roles:e.role,cadence:t.message.cadence,args:t.message.arguments.map(e=>t.arguments[e].asArgument),data:{},interaction:t,voucher:Rn(t)}}catch(e){throw console.error("buildSignable",e),e}}(r,n,e));e.accounts[t].signature=o}}function jn(e){return{cadence:e.message.cadence,refBlock:e.message.refBlock||null,computeLimit:e.message.computeLimit,arguments:e.message.arguments.map(n=>e.arguments[n].asArgument),proposalKey:{address:c(e.accounts[e.proposer].addr),keyId:e.accounts[e.proposer].keyId,sequenceNum:e.accounts[e.proposer].sequenceNum},payer:c(e.accounts[e.payer].addr),authorizers:e.authorizations.map(n=>c(e.accounts[n].addr)).reduce((e,n)=>e.find(e=>e===n)?e:[...e,n],[])}}async function Hn(e){const n=de(e,"ix.validators",[]);return ue(e,n.map(e=>n=>e(n,{Ok:N,Bad:v})))}async function $n(e){for(let n of Object.keys(e.accounts))e.accounts[n].addr=c(e.accounts[n].addr);return e}async function qn(e){const n=de(e,"ix.voucher-intercept");return E(n)&&await n(Rn(e)),e}const Mn=e=>e,Yn=(e,n=Mn)=>async t=>(await Be.get(`debug.${e}`)&&await n(t,(...n)=>{console.log(`debug[${e}] ---\n`,...n,"\n\n\n---")},e=>["\nAccounts:",{proposer:e.proposer,authorizations:e.authorizations,payer:e.payer},"\n\nDetails:",e.accounts].filter(Boolean)),t),Wn=ue([Je,Yn("cadence",(e,n)=>n(e.message.cadence)),Xe,Yn("arguments",(e,n)=>n(e.message.arguments,e.message)),Un,Yn("accounts",(e,n,t)=>n(...t(e))),async function(n){if(Y(n)&&null==n.message.refBlock){const t=await Be().get("accessNode.api"),r=await Be.first(["sdk.transport","sdk.send"]);e(r,"Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"),n.message.refBlock=(await r(he([Ke()]),{config:Be,response:Re,Buffer:s,ix:ge},{node:t}).then(qe)).id}return n},async function(n){if(Y(n)){var t=Object.values(n.accounts).find(e=>e.role.proposer);if(e(t,"Transactions require a proposer"),null==t.sequenceNum){const r=await Be().get("accessNode.api"),o=await Be.first(["sdk.transport","sdk.send"]);e(o,"Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"),n.accounts[t.tempId].sequenceNum=await o(await he([De(t.addr)]),{config:Be,response:Re,Buffer:s,ix:ge},{node:r}).then(qe).then(e=>e.keys).then(e=>e.find(e=>e.index===t.keyId)).then(e=>e.sequenceNumber)}}return n},zn,Yn("signatures",(e,n,t)=>n(...t(e))),$n,Hn,qn,Yn("resolved",(e,n)=>n(e))]);function Jn(...e){if(e.length>1){const[n,t]=e;return Jn((e,{Ok:r,Bad:o})=>n?r(e):o(e,t))}const[n]=e;return e=>n(e,{Ok:N,Bad:v})}const Vn=async(e=[],n={})=>{const t=await Be.first(["sdk.transport","sdk.send"],n.send),r=await Be.first(["sdk.resolve"],n.resolve||Wn);return n.node=n.node||await Be().get("accessNode.api"),Array.isArray(e)&&(e=ue(g(),e)),t(await r(e),{config:Be,response:Re,ix:ge,Buffer:s},n)};async function Zn(e){const n=await Be().where(/^decoder\./),t=Object.entries(n).map(([e,n])=>[e=`/${e.replace(/^decoder\./,"")}$/`,n]);return qe(e,Object.fromEntries(t))}class Qn extends Error{constructor(e){super(`\n        Encode Message From Signable Error: Unable to determine message encoding for signer addresss: ${e}. \n        Please ensure the address: ${e} is intended to sign the given transaction as specified by the transaction signable.\n      `.trim()),this.name="Unable To Determine Message Encoding For Signer Addresss"}}const Xn=(e,n)=>{let t=(e=>{let n=new Set(e.authorizers);return n.add(e.proposalKey.address),n.delete(e.payer),Array.from(n).map(u)})(e.voucher),r=(e=>{let n=new Set([e.payer]);return Array.from(n).map(u)})(e.voucher);const o=t.includes(u(n)),a=r.includes(u(n));if(!o&&!a)throw new Qn(n);const s={cadence:e.voucher.cadence,refBlock:e.voucher.refBlock,computeLimit:e.voucher.computeLimit,arguments:e.voucher.arguments,proposalKey:p({},e.voucher.proposalKey,{address:c(e.voucher.proposalKey.address)}),payer:c(e.voucher.payer),authorizers:e.voucher.authorizers.map(c),payloadSigs:e.voucher.payloadSigs.map(e=>p({},e,{address:c(e.address)}))};return o?en(s):nn(s)};function et(e,n){return console.warn('\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      "latestBlock()" is deprecated, please use "block()" for this and future versions of FCL\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0008-deprecate-latest-block-method\n  \n      ============================\n    ',"font-weight:bold;font-family:monospace;"),Vn([Ke(e)],n).then(qe)}function nt(e){return me("ix.validators",n=>Array.isArray(n)?n.push(e):[e])}function tt(e){return ue([n=>(n.block.height=e,n),nt(e=>{if("boolean"==typeof e.block.isSealed)throw new Error("Unable to specify both block height and isSealed.");if(e.block.id)throw new Error("Unable to specify both block height and block id.");return e})])}function rt(e){return ue([n=>(n.block.id=e,N(n)),nt((e,{Ok:n,Bad:t})=>V(e)?t(e,"Unable to specify a block id with a Get Account interaction."):"boolean"==typeof e.block.isSealed?t(e,"Unable to specify both block id and isSealed."):e.block.height?t(e,"Unable to specify both block id and block height."):n(e))])}function ot(n,{height:t,id:r}={},o){return e(!(r&&t),'Method: account -- Cannot pass "id" and "height" simultaneously'),r?Vn([De(n),rt(r)],o).then(qe):t?Vn([De(n),tt(t)],o).then(qe):Vn([De(n)],o).then(qe)}function at({sealed:n=!1,id:t,height:r}={},o={}){return e(!(n&&t||n&&r),'Method: block -- Cannot pass "sealed" with "id" or "height"'),e(!(t&&r),'Method: block -- Cannot pass "id" and "height" simultaneously'),t?Vn([Ke(),rt(t)],o).then(qe):r?Vn([Ke(),tt(r)],o).then(qe):Vn([Ke(n)],o).then(qe)}function st(e=[]){return ue(e.map(e=>O(e,{role:"authorizer"})))}function it(e,n,t,r){return{addr:e,signingFunction:n,keyId:t,sequenceNum:r}}function ct(e,n,t){return void 0===n&&void 0===t||console.warn("\n      %cFCL/SDK Deprecation Notice\n      ============================\n  \n      Passing a start and end into getEnvents has been deprecated and will not be supported in future versions of the Flow JS-SDK/FCL.\n      You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0005-deprecate-start-end-get-events-builder\n  \n      ============================\n    ","font-weight:bold;font-family:monospace;"),ue([K,r=>(r.events.eventType=e,r.events.start=n,r.events.end=t,N(r))])}function ut(e,n,t){return ue([K,r=>(r.events.eventType=e,r.events.start=n,r.events.end=t,N(r))])}function lt(e,n=[]){return ue([K,t=>(t.events.eventType=e,t.events.blockIds=n,N(t))])}function dt(e=null){return ue([j,n=>(n.block.isSealed=e,N(n))])}function pt(e=!1){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getLatestBlock builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0006-deprecate-get-latest-block-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),ue([D,n=>(n.block.isSealed=e,N(n))])}function mt(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockById builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0004-deprecate-get-block-by-id-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),ue([F,n=>(n.block.ids=[e],N(n))])}function ft(e){return console.warn("\n    %cFCL/SDK Deprecation Notice\n    ============================\n\n    The getBlockByHeight builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0003-deprecate-get-block-by-height-builder\n\n    ============================\n  ","font-weight:bold;font-family:monospace;"),ue([U,n=>(n.block.height=e,N(n))])}function gt(e=null){return ue([H,n=>(n.collection.id=e,n)])}function ht(e){return ue([L,n=>(n.transaction.id=e,N(n))])}function yt(e){return ue([x,n=>(n.transaction.id=e,N(n))])}function kt(e){return n=>(n.message.computeLimit=e,n)}function It(e=[]){return ue(e.map(C))}function bt(e,n){return{value:e,xform:n}}async function wt(e){return O(e,{role:"proposer"})}async function Tt(e){return O(e,{role:"payer"})}function Et(){return z}function At(e){return ue([n=>(n.message.refBlock=e,N(n))])}function Nt(...e){return ue([_,pe("ix.cadence",d(...e))])}const vt=[];function St(...e){return ue([B,pe("ix.cadence",d(...e)),e=>(e.message.computeLimit=e.message.computeLimit||10,e.message.refBlock=e.message.refBlock||null,e.authorizations=e.authorizations||vt,N(e))])}function Ot(e){return pe("ix.voucher-intercept",e)}const Ct=({node:n})=>async t=>{if(!Y(t))return N(t);if(t.accounts[t.proposer].sequenceNum)return N(t);const r=await Be.first(["sdk.transport","sdk.send"]);e(r,"Required value for sdk.transport is not defined in config. See: https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21");const o=await r(await he([De(t.accounts[t.proposer].addr)]),{config:Be,response:Re,Buffer:s,ix:ge},{node:n}),a=await qe(o);return t.accounts[t.proposer].sequenceNum=a.keys[t.accounts[t.proposer].keyId].sequenceNumber,N(t)},Gt=e=>e,_t=["tempId"];function Bt(e){return["SIGNATURE",e.addr,e.keyId].join(".")}function Lt(e={}){return function(n){const t=p({},n,e,{signingFunction:e.signingFunction||n.signingFunction||function(e){return{addr:t.addr,keyId:t.keyId,signature:Bt(t)}}});return t}}const xt={proposer:!1,authorizer:!1,payer:!1};var Rt={__proto__:null,mockSend:function(n=Gt){return async function(t){switch(t=await t,!0){case V(t):return function(n,t=5){return e(n.account,"mockAccountResponse(ix) -- ix.account is missing",n),e(n.account.addr,"mockAccountResponse(ix) -- ix.account.addr is missing",n),{account:{addr:n.account.addr,keys:Array.from({length:t},(e,n)=>({index:n,sequenceNumber:42}))}}}(t);case te(t):return{tag:"GET_BLOCK",block:{id:"32"}};default:return n(t)}}},authzFn:Lt,authzResolve:function(e={}){return function(n){const{tempId:t}=e;return p({},n,{tempId:t||"WITH_RESOLVE",resolve:Lt(function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n.indexOf(t=a[r])>=0||(o[t]=e[t]);return o}(e,_t))})}},authzResolveMany:function(e={}){return function(n){return p({},n,{tempId:e.tempId||"AUTHZ_RESOLVE_MANY",resolve:()=>[e.proposer&&Lt(e.proposer)({role:p({},xt,{proposer:!0})}),...e.authorizations.map(Lt).map(e=>e({role:p({},xt,{authorizer:!0})})),e.payer&&Lt(e.payer)({role:p({},xt,{payer:!0})})].filter(Boolean)})}},sig:Bt,idof:e=>`${e.addr}-${e.keyId}`,run:(e=[])=>he([At("123"),...e]).then(Wn)};const Kt="0.0.57-alpha.3",Dt=e=>{(({name:e,transitionsPath:n})=>{console.error(`\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The ${e} builder has been removed from the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: ${n}\n    ============================\n  `,"font-weight:bold;font-family:monospace;")})({name:"params",transitionsPath:"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"})},Ft=e=>(({name:e,transitionsPath:n})=>{console.warn(`\n    %cFCL/SDK Deprecation Notice\n    ============================\n    The ${e} builder has been deprecated and will be removed in future versions of the Flow JS-SDK/FCL.\n    You can learn more (including a guide on common transition paths) here: ${n}\n    ============================\n  `,"font-weight:bold;font-family:monospace;")})({name:"param",transitionsPath:"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"});export{Rt as TestUtils,Kt as VERSION,ot as account,bt as arg,It as args,tt as atBlockHeight,rt as atBlockId,it as authorization,st as authorizations,at as block,he as build,Be as config,Rn as createSignableVoucher,Zn as decode,fe as destroy,Xn as encodeMessageFromSignable,de as get,De as getAccount,Ke as getBlock,ft as getBlockByHeight,mt as getBlockById,dt as getBlockHeader,gt as getCollection,ct as getEvents,ut as getEventsAtBlockHeightRange,lt as getEventsAtBlockIds,pt as getLatestBlock,yt as getTransaction,ht as getTransactionStatus,g as interaction,Jn as invariant,se as isBad,V as isGetAccount,te as isGetBlock,ee as isGetBlockByHeight,X as isGetBlockById,re as isGetBlockHeader,oe as isGetCollection,Z as isGetEvents,Q as isGetLatestBlock,J as isGetTransaction,W as isGetTransactionStatus,ae as isOk,ne as isPing,M as isScript,Y as isTransaction,q as isUnknown,et as latestBlock,kt as limit,Ft as param,Dt as params,Tt as payer,Et as ping,ue as pipe,wt as proposer,pe as put,At as ref,Wn as resolve,Un as resolveAccounts,Xe as resolveArguments,Je as resolveCadence,$n as resolveFinalNormalization,Ct as resolveProposerSequenceNumber,Me as resolveRefBlockId,zn as resolveSignatures,Hn as resolveValidators,qn as resolveVoucherIntercept,Nt as script,Vn as send,St as transaction,me as update,nt as validator,Ot as voucherIntercept,Kn as voucherToTxId,ie as why};
//# sourceMappingURL=sdk.modern.js.map
